int counter = 0;

Thread t1 = new Thread(Increment);
Thread t2 = new Thread(Increment);

t1.Start();
t2.Start();

t1.Join();
t2.Join();

Console.WriteLine($"Result: counter = {counter}");

// Interlocked - клас, який надає атомарні операції для змінних, що використовуються в багатопотоковому середовищі
void Increment()
{
    for (int i = 0; i < 100000; i++)
    {
        Interlocked.Increment(ref counter); // атомарна операція
    }
}

// використання Interlocked для такого завдання (++counter) - це найпростіше і найшвидше рішення
// Interlocked також має інші методи, наприклад Decrement, Add, Exchange, CompareExchange
// для більш складних операцій, які не можна виконати атомарно, використовують lock або інші механізми синхронізації
// lock - більш універсальний, але повільніший через накладні витрати на блокування і розблокування
// Interlocked - швидкий, але обмежений набором операцій
// вибір між Interlocked і lock залежить від конкретного завдання і вимог до продуктивності
// Interlocked підходить для простих операцій над змінними, які можна виконати атомарно
// lock підходить для більш складних операцій або коли потрібно захистити більший блок коду
// в реальних додатках часто використовують комбінацію обох підходів в залежності від контексту
// важливо розуміти, що Interlocked працює лише з певними типами даних (int, long, IntPtr) і не підходить для складних об'єктів або структур
// Mutex, Semaphore, ReaderWriterLockSlim - інші механізми синхронізації, які можуть бути корисні в певних сценаріях